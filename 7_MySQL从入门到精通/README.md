# MySQL从入门到精通学习笔记

## 1. SQL语言分类

SQL语言全称为结构化查询语言，分为以下4个子类：DQMC。

1. 数据定义语言：简称DDL（Data Definition Language），用来定义数据库对象：数据库、表、列等。关键字：create、alter、drop等
2. 数据查询语言：简称DQL（Data Query Language），用来查询数据库中表的记录。关键字：select、from、where等
3. 数据操作语言：简称DML（Data Manipulation Language），用来对数据库中表的记录进行更新。关键字：insert、delete、update等
4. 数据控制语言：简称DCL（Data Control Language），用来定义数据库的访问权限和安全级别，及创建用户，关键字：grant等

## 2. SQL解析顺序（重点）

**问题1**：SQL语句的解析顺序是什么样的？

示例SQL：

```sql
SELECT DISTINCT
    < select_list >
FROM
    < left_table > < join_type >
JOIN < right_table > ON < join_condition >
WHERE
    < where_condition >
GROUP BY
    < group_by_list >
HAVING
    < having_condition >
ORDER BY
    < order_by_condition >
LIMIT < limit_number >
```

解析顺序：行过滤——列过滤——排序——LIMIT（MySQL特有）

```sql
-- 行过滤
FROM < left_table > 
ON < join_condition >
< join_type > JOIN < right_table > -- 多表连接时循环执行，构建表与表的笛卡尔积
WHERE < where_condition > -- 从左往右循环执行每个条件
GROUP BY < group_by_list >
HAVING < having_condition >
-- 列过滤
SELECT DISTINCT < select_list >
-- 排序
ORDER BY < order_by_condition >
-- MySQL特有
LIMIT < limit_number >
```

## 3. MySQL架构

### 3.1 MySQL文件结构

#### 日志文件

MySQL包含4类日志文件：错误日志、二进制日志（bin log）、通用查询日志和慢查询日志。错误日志记录了所有发生过的错误信息，可用于定位问题。

```shell
# 可以直接定义为文件路径，也可以为ON|OFF 
log_error=/var/log/mysqld.log 
# 是否将警告信息也定义至错误日志中
log_warings=1
```

二进制日志bin log记录数据库所有DDL（直接记录）和DML（必须事务提交），实现主从复制、数据备份和数据恢复。

```shell
log-bin=mysql-bin
```

通用查询日志记录用户所有操作，只用于调试数据库，平时不开启，否则会产生大量磁盘IO。慢查询日志默认也是关闭的，它记录执行时间超过long_query_time秒的所有查询，用于收集查询时间比较长的SQL语句。

#### 数据文件

InnoDB存储引擎产生3种数据文件：

1. frm文件：表结构的定义信息
2. ibd文件：使用独享表空间存储表数据和索引信息
3. ibdata文件：使用共享表空间存储表数据和索引信息

MyISAM存储引擎产生3种数据文件：

1. frm文件：表结构的定义信息
2. myi文件：表数据文件中任何索引的数据树
3. myd文件：表数据信息

### 3.2 MySQL逻辑架构

![](/Users/likejun/javaee-architect/7_MySQL从入门到精通/assets/mysql逻辑架构.png)

#### MySQL Server层（重点）

Server层涉及到几个对象：连接器、查询缓存、分析器、优化器、执行器和存储引擎。

**问题2**：SQL语句的执行流程是什么样的？

1. 客户端通过连接器连接到MySQL服务器，并向MySQL发送SQL语句
2. 服务器先在查询缓存中查找，如果缓存命中了就直接返回
3. 否则分析器就对SQL语句进行词法分析、语法分析和预处理，并生成抽象语法树
4. 优化器再对生成的抽象语法树进行优化，即选择最优执行计划
5. 执行器进行权限验证，验证通过后调用存储引擎提供的接口执行语句，有索引则直接查询索引，没有索引则全表扫描并过滤。

#### InnoDB存储引擎（重点）

**问题3**：MySQL有哪些常用的可插拔存储引擎？

1. InnoDB：默认存储引擎，支持事务和行级锁
2. MyISAM：插入查询速度快，但不支持事务
3. Memory：所有数据存储在内存中，重启服务后就丢失
4. Falcon：据说是InnoDB的替代者
5. CSV：以CSV格式存储数据

![](/Users/likejun/javaee-architect/7_MySQL从入门到精通/assets/imdb架构图.png)

InnoDB分为两大部分：磁盘文件和内存结构。磁盘文件部分包含redo log重做日志文件、系统表空间和用户表空间。当InnoDB数据文件发生错误时重做日志文件可以恢复数据。重做日志是两个文件循环写入的，可以通过配置文件设置日志文件大小。

系统表空间是共享的，它存储InnoDB数据字典、double write buffer、change buffer和undo logs。用户表空间存储表的数据和索引信息。InnoDB逻辑存储结构：表空间、段（数据段、索引段、回滚段）、区、页、行。

内存结构包括Buffer Pool缓冲池、额外内存池、redo log buffer重做日志缓冲。Buffer Pool缓冲池包括数据页、索引页、更新缓冲、自适应哈希索引、锁信息和数据字典信息（数据、库对象和表对象的元信息集合）。

【TODO】InnoDB工作原理：内存数据落盘、CheckPoint检查点机制和Double Write的工作原理。

## 4. MySQL集群搭建与分库分表

### 4.1 主从复制集群

**问题4**：主从复制的原理是什么？

搭建MySQL主从复制服务器集群的原理是基于binlog实现的。binlog可用于恢复本机数据或实现主从复制。在一个主从复制的MySQL集群中，主服务器负责写，从服务器负责读。主服务器上的增删改操作会记录到主服务器的binlog日志中，一旦binlog刷写到磁盘，主服务器就会发消息通知从服务器，从服务器上的IO线程会向主服务器请求binlog并将其写入relaylog。之后从服务器上的SQL线程（5.7版后不止一个）会读取relaylog并在从服务器上进行重放，从而实现主从同步。

![](/Users/likejun/javaee-architect/7_MySQL从入门到精通/assets/主从复制.png)

#### binlog三种模式

1. statement：每一条会修改数据的sql都会记录到master的bin-log中。优点是解决了row level下的缺点，不需要记录每一行数据的变化， 减少binlog日志量，节约IO，提高性能；缺点是修改数据的时候如果使用了某些特定的函数或者功能的时候会出现复制问题
2. row：记录每一行数据被修改的形式。优点是可以不记录执行的SQL语句的上下文信息，仅仅只需要记录哪一条记录被修改了。不会出现某些特定情况下的存储过程、function以及trigger的调用和触发无法被正确复制的问题；缺点是会产生大量的日志内容，binlog日志的量会很大
3. mixed：前两种模式的结合，在mixed模式下，MySQL会根据执行的每一条具体的SQL语句来区分对待记录的日志形式，也就是在statement和row之间选一种

#### binlog刷盘策略：sync_binlog参数

* 0：存储引擎不进行binlog的刷新到磁盘，而由操作系统的文件系统控制缓存刷新
* 1：每提交一次事务，存储引擎调用文件系统的sync操作进行一次缓存的刷新，这种方式最安全，但性能较低
* n：当提交的日志组为n时，存储引擎调用文件系统的sync操作进行一次缓存的刷新

#### 主从同步延迟

产生主从延迟的原因是从服务器压力过大。一个服务器开放N个链接给客户端来，有可能产生大并发的更新操作，但是从服务器读取binlog的线程仅有一个，当某个SQL在从服务器上执行的时间稍长或者由于某个SQL要进行锁表就会导致主服务器的SQL大量积压，未被同步到从服务器里。这就导致了主从不一致。

主从同步延迟只能采取措施进行缓解，没有什么一招制敌的办法。因为本质上所有的SQL都必须在从服务器里面执行一遍。主服务器如果源源不断的有更新操作，那么一旦有延迟产生，加重的可能性就会越来越大。可以采取3种措施缓解：

* 主服务器负责更新操作，对安全性的要求比从服务器高。可以设置比如sync_binlog=1，innodb_flush_log_at_trx_commit = 1。从服务器不需要这么高的数据安全，可以设置sync_binlog为0或者关闭binlog。innodb_flushlog/innodb_flush_log_at_trx_commit也可以设置为0来从很大程度上提高效率。另外就是使用比主库更好的硬件设备作为从服务器
* 把从服务器完全作为备份使用，不提供查询，负载下来了执行relay log的效率自然就高了
* 增加从服务器，分散读的压力，从而降低服务器负载

MySQL可以查看从服务器状态，可以通过`show slave status`查看Seconds_Behind_Master参数的值来判断：

1. NULL：表示io_thread或是sql_thread有任何一个发生故障，也就是该线程的Running状态是No，而非 Yes
2. 0：该值为0表示主从复制状态正常

### 4.2 读写分离集群

MySQL的主从复制只保证主服务器对外提供服务，而从服务器一般只作为备份用，不对外提供服务。在一个高可用的MySQL集群中，采取的方式是主服务器提供读写服务，而多个从服务器则提供读服务。Atlas是奇虎360在MySQL-Proxy基础上提供的读写分离解决方案。

### 4.3 分库分表

单机的存储能力、连接数是有限的，随着业务规模的扩大会变成性能瓶颈。单表数据量在百万以内时还可以通过添加从库、优化索引提升性能。一旦数据量朝着千万以上趋势增长，再怎么优化数据库，很多操作性能仍然会严重下降。为了降低数据库的负担，提升数据库响应速度，缩短查询时间，需要进行分库分表。

**问题5**：数据分片的方案和规则

分库分表需要将大量数据分散到多个数据库中，即对数据进行分片（Sharding），使每个数据库中数据量小，响应速度快，提升数据库整体性能。分片方案大致可以分为：垂直（纵向）分片和水平（横向）分片两种。

![](/Users/likejun/javaee-architect/7_MySQL从入门到精通/assets/垂直分库.png)

**垂直分片**包括垂直分库和垂直分表。垂直分库按照业务分类进行划分，每个业务有独立数据库。垂直分表就像竖着把一块蛋糕切成了两个部分：一个部分是频繁访问的热点数据（核心表），一个部分是不频繁访问到的数据（扩展表）。MySQL是行式数据库，垂直分表可以加载更多内存到数据中。

* 优点：业务间解耦，不同业务的数据进行独立的维护、监控、扩展。在高并发场景下，一定程度上缓解了数据库的压力

* 缺点：提升了开发的复杂度，由于业务的隔离性，很多表无法直接访问，必须通过代码来聚合数据。分布式事务管理难度增加。数据库还是存在单表数据量过大的问题，需要配合水平分表进行进一步分片

**水平分片**就像把一块蛋糕横着切成了两个部分，每个部分都包含整个数据的一个子集。水平分片将一张大表切分成多个表结构相同，而每个表只占原表一部分数据，然后按不同的条件分散到多个数据库中。比如一张2000万行数据的order表水平切分成四个表：order_1、order_2、order_3和order_4，每张表数据500万。

水平分片又分为**库内分表**和**分库分表**。库内分表将表拆分，每个子表都在同一个数据库实例中，解决了单一表数据量过大的问题，没有将拆分后的表分布到不同节点的库上，还在竞争同一个物理机的CPU、内存和网络IO等资源。分库分表则将切分出来的子表分散到不同的数据库中，从而使得单个表的数据量变小，达到分布式的效果。

* 优点：解决高并发时单库数据量过大的问题，提升系统稳定性和负载能力，业务系统改造的工作量不是很大

* 缺点：跨分片的事务一致性难以保证，跨库的连表查询性能较差，扩容的难度和维护量较大

分库分表后，数据在不同数据库、不同表中的分布策略有两种：（1）根据取值范围分布；（2）根据散列分布。

根据取值范围，按照时间区间或ID区间来切分。假如我们切分的是用户表，可以定义每个库的User表里只存10000条数据，第一个库userId从0~9999，第二个库10000 ~ 19999，第三个库20000 ~ 29999......以此类推。

* 优点：单表数据量是可控的。水平扩展简单只需增加节点即可，无需对其他分片的数据进行迁移。能快速定位要查询的数据在哪个库

* 缺点：连续分片可能存在数据热点。如果按时间字段分片，有些分片存储最近时间段内的数据，可能会被频繁的读写，而有些分片存储的历史数据，则很少被查询

hash取模的切分方式比较常见，还拿User表举例，对数据库从0到N-1进行编号，对User表中userId字段进行取模，得到余数i ，i=0存第一个库，i=1存第二个库，i=2存第三个库....以此类推。这样同一个用户的数据都会存在同一个库里，用userId作为条件查询就很好定位了。

* 优点：数据分片相对比较均匀，不易出现某个库并发访问的问题
* 缺点：当某一台机器宕机，本应该落在该数据库的请求就无法得到正确的处理，这时宕掉的实例会被踢出集群，此时算法变成mod N-1，用户信息可能就不再在同一个库中

ShardingSphere是目前最好的分库分表工具。













